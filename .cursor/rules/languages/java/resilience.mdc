---
description: "Resilience4j patterns - retry, circuit breaker, rate limiter, bulkhead for Spring Boot MVC and RestClient"
globs: ["**/*Client*.java", "**/*Service*.java", "**/config/*Resilience*.java"]
---

# Resilience4j Patterns

> **Note:** These patterns work with Spring MVC and RestClient. For reactive applications, see WebFlux-specific resilience patterns.

## Dependencies

```xml
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot3</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

## Configuration (application.yml)

```yaml
resilience4j:
  retry:
    instances:
      paymentService:
        max-attempts: 3
        wait-duration: 500ms
        exponential-backoff-multiplier: 2
        retry-exceptions:
          - org.springframework.web.client.HttpServerErrorException
          - java.net.SocketTimeoutException
  
  circuitbreaker:
    instances:
      paymentService:
        failure-rate-threshold: 50
        slow-call-rate-threshold: 50
        slow-call-duration-threshold: 2s
        permitted-number-of-calls-in-half-open-state: 3
        sliding-window-type: COUNT_BASED
        sliding-window-size: 10
        minimum-number-of-calls: 5
        wait-duration-in-open-state: 30s
        automatic-transition-from-open-to-half-open-enabled: true
  
  ratelimiter:
    instances:
      paymentService:
        limit-for-period: 10
        limit-refresh-period: 1s
        timeout-duration: 0s
  
  timelimiter:
    instances:
      paymentService:
        timeout-duration: 5s
  
  bulkhead:
    instances:
      paymentService:
        max-concurrent-calls: 5
        max-wait-duration: 1s

management:
  endpoints:
    web:
      exposure:
        include: health,metrics,circuitbreakers,ratelimiters
  health:
    circuitbreakers:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true
```

## Retry Pattern

### With RestClient

```java
@Service
public class PaymentService {
    
    private final RestClient restClient;
    
    public PaymentService(RestClient.Builder restClientBuilder) {
        this.restClient = restClientBuilder
            .baseUrl("https://payment-api.example.com")
            .build();
    }
    
    @Retry(name = "paymentService", fallbackMethod = "paymentFallback")
    public PaymentResponse processPayment(PaymentRequest request) {
        return restClient.post()
            .uri("/api/payments")
            .body(request)
            .retrieve()
            .body(PaymentResponse.class);
    }
    
    // Fallback method must have same signature + Throwable parameter
    private PaymentResponse paymentFallback(PaymentRequest request, Throwable t) {
        log.error("Payment processing failed, returning fallback", t);
        return new PaymentResponse("FAILED", "Service temporarily unavailable");
    }
}
```

## Circuit Breaker Pattern

### With RestClient (Spring MVC)

```java
@Service
public class ExternalApiClient {
    
    private final RestClient restClient;
    
    public ExternalApiClient(RestClient.Builder restClientBuilder) {
        this.restClient = restClientBuilder
            .baseUrl("https://api.example.com")
            .build();
    }
    
    @CircuitBreaker(name = "paymentService", fallbackMethod = "fallbackResponse")
    public ApiResponse callExternalApi(String endpoint) {
        return restClient.get()
            .uri(endpoint)
            .retrieve()
            .body(ApiResponse.class);
    }
    
    private ApiResponse fallbackResponse(String endpoint, Throwable t) {
        log.warn("Circuit breaker activated for {}, error: {}", endpoint, t.getMessage());
        return new ApiResponse("Circuit breaker activated");
    }
}
```

### Circuit Breaker for BFF Aggregation

```java
@Service
public class OrderAggregationService {
    
    @CircuitBreaker(name = "orderService", fallbackMethod = "orderFallback")
    public OrderDto getOrder(UUID orderId) {
        return orderClient.getOrder(orderId);
    }
    
    @CircuitBreaker(name = "inventoryService", fallbackMethod = "inventoryFallback")
    public List<InventoryItem> getInventory(UUID orderId) {
        return inventoryClient.getInventory(orderId);
    }
    
    // Fallback methods
    private OrderDto orderFallback(UUID orderId, Throwable t) {
        log.warn("Order service unavailable for {}, returning cached data", orderId);
        return getCachedOrder(orderId).orElse(new OrderDto(orderId, "UNAVAILABLE"));
    }
    
    private List<InventoryItem> inventoryFallback(UUID orderId, Throwable t) {
        log.warn("Inventory service unavailable for {}", orderId);
        return List.of(); // Return empty list on failure
    }
    
    // Aggregate with partial failure support
    public OrderSummary getOrderSummary(UUID orderId) {
        var order = getOrder(orderId); // May return fallback
        var inventory = getInventory(orderId); // May return empty list
        
        return new OrderSummary(order, inventory);
    }
}
```

## Rate Limiter Pattern

```java
@Service
public class ThirdPartyService {
    
    @RateLimiter(name = "paymentService", fallbackMethod = "rateLimitFallback")
    public String callRateLimitedApi(String request) {
        // This method will be rate limited
        return externalApi.call(request);
    }
    
    private String rateLimitFallback(String request, RequestNotPermitted e) {
        log.warn("Rate limit exceeded for request: {}", request);
        return "Rate limit exceeded, please try again later";
    }
}
```

## Time Limiter Pattern

### With CompletableFuture

```java
@Service
public class SlowService {
    
    private final RestClient restClient;
    
    public SlowService(RestClient.Builder restClientBuilder) {
        this.restClient = restClientBuilder
            .baseUrl("https://slow-api.example.com")
            .build();
    }
    
    @TimeLimiter(name = "paymentService", fallbackMethod = "timeoutFallback")
    public CompletableFuture<String> callSlowApi(String request) {
        return CompletableFuture.supplyAsync(() -> 
            restClient.get()
                .uri("/api/slow/{request}", request)
                .retrieve()
                .body(String.class)
        );
    }
    
    private CompletableFuture<String> timeoutFallback(String request, TimeoutException e) {
        log.warn("Request timeout for: {}", request);
        return CompletableFuture.completedFuture("Request timeout");
    }
}
```

## Bulkhead Pattern

```java
@Service
public class ResourceIntensiveService {
    
    @Bulkhead(name = "paymentService", type = Bulkhead.Type.SEMAPHORE, fallbackMethod = "bulkheadFallback")
    public String processRequest(String request) {
        // Only N concurrent calls allowed
        return heavyOperation(request);
    }
    
    private String bulkheadFallback(String request, BulkheadFullException e) {
        log.warn("Bulkhead full for request: {}", request);
        return "Too many concurrent requests, please try again";
    }
}
```

## Combining Patterns

```java
@Service
public class ResilientService {
    
    // Order: Retry -> CircuitBreaker -> RateLimiter -> TimeLimiter -> Bulkhead
    @Retry(name = "paymentService")
    @CircuitBreaker(name = "paymentService", fallbackMethod = "fallback")
    @RateLimiter(name = "paymentService")
    @TimeLimiter(name = "paymentService")
    @Bulkhead(name = "paymentService")
    public CompletableFuture<PaymentResponse> processPayment(PaymentRequest request) {
        return CompletableFuture.supplyAsync(() -> 
            externalPaymentApi.process(request)
        );
    }
    
    private CompletableFuture<PaymentResponse> fallback(PaymentRequest request, Throwable t) {
        log.error("All resilience patterns exhausted", t);
        return CompletableFuture.completedFuture(
            new PaymentResponse("FAILED", "Service unavailable")
        );
    }
}
```

## When to Use Each Strategy

| Strategy | Use Case |
|----------|----------|
| **Retry** | Transient failures (network blips, temporary 503s) |
| **Circuit Breaker** | Failing dependencies (prevent cascade failures) |
| **Rate Limiter** | Respect external API limits, protect own resources |
| **Time Limiter** | Unresponsive services, enforce SLAs |
| **Bulkhead** | Isolate resources per operation type |

## Conventions

- ALWAYS use exponential backoff for retries
- Configure circuit breakers for all external HTTP calls
- Set reasonable timeouts (don't rely on defaults)
- Log all resilience events for observability
- Use fallback methods for graceful degradation
- Don't retry non-idempotent operations without idempotency keys
- Combine patterns in correct order: Retry -> CircuitBreaker -> RateLimiter -> TimeLimiter -> Bulkhead

**See also:** `logging.mdc`, `error-handling.mdc`, `dependencies.mdc`
