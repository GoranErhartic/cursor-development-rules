---
description: "Code quality standards - Java 25 LTS idioms, naming conventions, records, sealed classes, virtual threads"
globs: ["**/*.java"]
---

# Code Quality Standards

## Java 25 LTS Best Practices

### Use Records for DTOs and Value Objects
```java
// DTO
public record UserDto(UUID id, String email, String name) {}

// Value Object
public record Money(BigDecimal amount, String currency) {}

// Command
public record CreateUserCommand(String email, String name) implements Command<Result<UUID>> {}
```

### Sealed Classes for Domain Hierarchies
```java
public sealed interface PaymentMethod permits CreditCard, BankTransfer, PayPal {
    Money getAmount();
}

public record CreditCard(String cardNumber, Money amount) implements PaymentMethod {
    @Override
    public Money getAmount() { return amount; }
}
```

### Pattern Matching
```java
return switch (user) {
    case null -> ResponseEntity.notFound().build();
    case User u when !u.isActive() -> ResponseEntity.status(HttpStatus.FORBIDDEN).build();
    default -> ResponseEntity.ok(user);
};
```

### Text Blocks
```java
String query = """
    SELECT u FROM User u
    WHERE u.email = :email
    AND u.active = true
    """;
```

## Naming Conventions

| Element | Convention | Example |
|---------|------------|---------|
| Class | PascalCase | `UserService` |
| Interface | PascalCase (NO 'I' prefix) | `UserRepository` |
| Method | camelCase | `findById` |
| Parameter | camelCase | `userId` |
| Private field | camelCase | `userRepository` |
| Constant | UPPER_SNAKE_CASE | `MAX_RETRY_COUNT` |
| Package | lowercase | `com.example.user` |

## Self-Documenting Code

- Use **intention-revealing names** — `findActiveUsersByDepartment` not `findUsers`
- Prefer clarity over brevity
- Comments explain **why**, not **what**
- Extract complex conditions into named booleans or methods

```java
// BAD
if (u.getStatus() == 1 && u.getCreatedAt().isAfter(LocalDateTime.now().minusDays(30))) { }

// GOOD
boolean isRecentlyActiveUser = user.isActive() && user.wasCreatedWithinDays(30);
if (isRecentlyActiveUser) { }
```

## Anti-Patterns to Avoid

- ❌ God classes with too many responsibilities
- ❌ Anemic domain models (logic in services, dumb entities)
- ❌ Premature optimization
- ❌ Over-engineering for hypothetical requirements
- ❌ Catching generic `Exception` without proper handling
- ❌ Magic numbers and hardcoded strings
- ❌ Circular dependencies
- ❌ Returning `null` (use `Optional<T>` instead)

## Modern Java Practices

### Use Optional for Nullable Returns
```java
// GOOD
public Optional<User> findById(UUID id) {
    return userRepository.findById(id);
}

// BAD
public User findById(UUID id) {
    return userRepository.findById(id).orElse(null);
}
```

### Use Stream API
```java
List<String> activeEmails = users.stream()
    .filter(User::isActive)
    .map(User::getEmail)
    .toList();
```

### Use var for Local Variables
```java
var user = userRepository.findById(id).orElseThrow();
var query = entityManager.createQuery("SELECT u FROM User u", User.class);
```

## HTTP Clients (RestClient)

### Use RestClient for HTTP Calls

**Spring Boot 4+ provides RestClient** — a modern, fluent HTTP client that replaces RestTemplate.

```java
// GOOD - RestClient with builder pattern
@Service
public class UserApiClient {
    
    private final RestClient restClient;
    
    public UserApiClient(RestClient.Builder restClientBuilder) {
        this.restClient = restClientBuilder
            .baseUrl("https://api.example.com")
            .defaultHeader("Accept", "application/json")
            .build();
    }
    
    public UserDto getUser(UUID userId) {
        return restClient.get()
            .uri("/users/{id}", userId)
            .retrieve()
            .body(UserDto.class);
    }
}

// AVOID - RestTemplate (legacy)
@Service
public class LegacyUserClient {
    private final RestTemplate restTemplate = new RestTemplate(); // Don't use
}
```

### Declarative HTTP Interface

```java
// Define interface
public interface UserApiClient {
    
    @GetExchange("/users/{id}")
    UserDto getUser(@PathVariable UUID id);
    
    @PostExchange("/users")
    UserDto createUser(@RequestBody CreateUserRequest request);
}

// Configure as bean
@Configuration
public class HttpClientConfig {
    
    @Bean
    public UserApiClient userApiClient(RestClient.Builder builder) {
        var restClient = builder
            .baseUrl("https://api.example.com")
            .build();
        
        var factory = HttpServiceProxyFactory
            .builderFor(RestClientAdapter.create(restClient))
            .build();
        
        return factory.createClient(UserApiClient.class);
    }
}
```

## Virtual Threads

### Enable Virtual Threads

**Java 25+ with Spring Boot 4+** supports virtual threads for improved scalability.

```yaml
# application.yml
spring:
  threads:
    virtual:
      enabled: true
```

### Virtual Thread Considerations

```java
// Virtual threads work seamlessly with blocking operations
@Service
public class OrderService {
    
    private final RestClient restClient;
    
    // This method runs on a virtual thread when called from a controller
    public OrderDto getOrder(UUID orderId) {
        // Blocking I/O - efficient with virtual threads
        return restClient.get()
            .uri("/orders/{id}", orderId)
            .retrieve()
            .body(OrderDto.class);
    }
}

// Use CompletableFuture for parallel operations
public CompletableFuture<OrderSummary> getOrderSummary(UUID orderId) {
    var orderFuture = CompletableFuture.supplyAsync(
        () -> orderClient.getOrder(orderId)
    );
    
    var itemsFuture = CompletableFuture.supplyAsync(
        () -> itemClient.getItems(orderId)
    );
    
    return orderFuture.thenCombine(itemsFuture, 
        (order, items) -> new OrderSummary(order, items));
}
```

**Guidelines:**
- Virtual threads are suitable for I/O-bound operations (database, HTTP calls)
- Avoid thread pools with virtual threads (use direct execution)
- Don't use `ThreadLocal` extensively (creates overhead)
- Blocking operations are fine — virtual threads handle them efficiently

## Boy Scout Rule

> "Always leave the code better than you found it."

- Fix small issues as you encounter them
- Remove dead code and unused imports
- Keep improvements proportional to the task

**See also:** `architecture.mdc`
