---
description: "State management - Zustand stores, React 19 hooks, context patterns, derived state"
globs: ["**/stores/**/*.ts", "**/hooks/**/*.ts", "**/*.tsx"]
---

# State Management

## State Management Decision Tree

```
┌─────────────────────────────────────┐
│ Does state belong to one component? │
└────────────┬────────────────────────┘
             │
      ┌──────┴──────┐
      │ YES         │ NO
      │             │
      v             v
   useState     ┌────────────────────────┐
                │ Shared by 2-3 children? │
                └────────┬───────────────┘
                         │
                  ┌──────┴──────┐
                  │ YES         │ NO
                  │             │
                  v             v
             Lift state up  ┌──────────────────┐
             or useContext  │ Is it server data?│
                            └─────┬────────────┘
                                  │
                           ┌──────┴──────┐
                           │ YES         │ NO
                           │             │
                           v             v
                    TanStack Query    Zustand
```

## Local Component State

### useState
```typescript
function Counter() {
  const [count, setCount] = useState(0);
  const [user, setUser] = useState<User | null>(null);

  // Functional updates for state based on previous value
  const increment = () => setCount(prev => prev + 1);

  // Lazy initialization for expensive computation
  const [data] = useState(() => expensiveComputation());

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

### useReducer
```typescript
// GOOD - Complex state logic
interface State {
  count: number;
  step: number;
  history: number[];
}

type Action =
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'setStep'; payload: number }
  | { type: 'reset' };

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'increment':
      return {
        ...state,
        count: state.count + state.step,
        history: [...state.history, state.count + state.step],
      };
    case 'decrement':
      return {
        ...state,
        count: state.count - state.step,
        history: [...state.history, state.count - state.step],
      };
    case 'setStep':
      return { ...state, step: action.payload };
    case 'reset':
      return { count: 0, step: 1, history: [] };
    default:
      return state;
  }
}

function ComplexCounter() {
  const [state, dispatch] = useReducer(reducer, {
    count: 0,
    step: 1,
    history: [],
  });

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <input
        type="number"
        value={state.step}
        onChange={(e) =>
          dispatch({ type: 'setStep', payload: Number(e.target.value) })
        }
      />
    </div>
  );
}
```

## React 19 New Hooks

### use() - Resource Loading
```typescript
// Suspends component until promise resolves
function UserProfile({ userPromise }: { userPromise: Promise<User> }) {
  const user = use(userPromise);
  
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}

// Usage with Suspense
function App() {
  const userPromise = fetchUser('123');
  
  return (
    <Suspense fallback={<Spinner />}>
      <UserProfile userPromise={userPromise} />
    </Suspense>
  );
}
```

### useOptimistic - Optimistic Updates
```typescript
interface Todo {
  id: string;
  title: string;
  completed: boolean;
}

function TodoList({ todos }: { todos: Todo[] }) {
  const [optimisticTodos, addOptimisticTodo] = useOptimistic(
    todos,
    (state, newTodo: Todo) => [...state, newTodo]
  );

  async function createTodo(formData: FormData) {
    const title = formData.get('title') as string;
    const tempTodo: Todo = {
      id: crypto.randomUUID(),
      title,
      completed: false,
    };

    // Show optimistically
    addOptimisticTodo(tempTodo);

    // Send to server
    await fetch('/api/todos', {
      method: 'POST',
      body: JSON.stringify(tempTodo),
    });
  }

  return (
    <div>
      <ul>
        {optimisticTodos.map((todo) => (
          <li key={todo.id}>{todo.title}</li>
        ))}
      </ul>
      <form action={createTodo}>
        <input name="title" />
        <button type="submit">Add</button>
      </form>
    </div>
  );
}
```

### useFormStatus - Form State
```typescript
function SubmitButton() {
  const { pending, data, method, action } = useFormStatus();

  return (
    <button type="submit" disabled={pending}>
      {pending ? 'Submitting...' : 'Submit'}
    </button>
  );
}

function LoginForm() {
  async function handleLogin(formData: FormData) {
    await login(formData);
  }

  return (
    <form action={handleLogin}>
      <input name="email" type="email" required />
      <input name="password" type="password" required />
      <SubmitButton />
    </form>
  );
}
```

### useActionState - Server Actions with State
```typescript
interface FormState {
  message: string;
  errors?: Record<string, string[]>;
}

async function submitForm(
  prevState: FormState,
  formData: FormData
): Promise<FormState> {
  // Server-side validation
  const email = formData.get('email');
  
  if (!email) {
    return {
      message: 'Failed',
      errors: { email: ['Email is required'] },
    };
  }

  // Process form
  await saveToDatabase(formData);
  
  return { message: 'Success' };
}

function ContactForm() {
  const [state, formAction] = useActionState(submitForm, {
    message: '',
  });

  return (
    <form action={formAction}>
      <input name="email" type="email" />
      {state.errors?.email && (
        <span className="error">{state.errors.email[0]}</span>
      )}
      <button type="submit">Submit</button>
      {state.message && <p>{state.message}</p>}
    </form>
  );
}
```

## Context API

### Creating Context
```typescript
// GOOD - Proper TypeScript typing
interface ThemeContextValue {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextValue | null>(null);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');

  const toggleTheme = useCallback(() => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  }, []);

  const value = useMemo(
    () => ({ theme, toggleTheme }),
    [theme, toggleTheme]
  );

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

// Custom hook for consuming context
export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// Usage
function App() {
  return (
    <ThemeProvider>
      <Header />
      <Main />
    </ThemeProvider>
  );
}

function Header() {
  const { theme, toggleTheme } = useTheme();
  return <button onClick={toggleTheme}>{theme}</button>;
}
```

### Context Best Practices

```typescript
// BAD - Single giant context
interface AppContextValue {
  user: User;
  theme: Theme;
  settings: Settings;
  notifications: Notification[];
  // ... 20 more properties
}

// GOOD - Separate contexts by concern
// auth-context.tsx
export function AuthProvider({ children }: PropsWithChildren) {
  const [user, setUser] = useState<User | null>(null);
  // Auth-specific logic
  return <AuthContext.Provider value={{ user, setUser }}>{children}</AuthContext.Provider>;
}

// theme-context.tsx
export function ThemeProvider({ children }: PropsWithChildren) {
  const [theme, setTheme] = useState<Theme>('light');
  // Theme-specific logic
  return <ThemeContext.Provider value={{ theme, setTheme }}>{children}</ThemeContext.Provider>;
}
```

## Zustand - Global State Management

### Basic Store
```typescript
// stores/userStore.ts
import { create } from 'zustand';

interface User {
  id: string;
  name: string;
  email: string;
}

interface UserState {
  user: User | null;
  isLoading: boolean;
  error: Error | null;
  setUser: (user: User | null) => void;
  fetchUser: (id: string) => Promise<void>;
  logout: () => void;
}

export const useUserStore = create<UserState>((set) => ({
  user: null,
  isLoading: false,
  error: null,

  setUser: (user) => set({ user }),

  fetchUser: async (id) => {
    set({ isLoading: true, error: null });
    try {
      const user = await fetch(`/api/users/${id}`).then(res => res.json());
      set({ user, isLoading: false });
    } catch (error) {
      set({ error: error as Error, isLoading: false });
    }
  },

  logout: () => set({ user: null, error: null }),
}));

// Usage in component
function UserProfile() {
  const { user, isLoading, fetchUser } = useUserStore();

  useEffect(() => {
    fetchUser('123');
  }, [fetchUser]);

  if (isLoading) return <Spinner />;
  if (!user) return null;

  return <div>{user.name}</div>;
}

// Selective subscription - only re-render when user changes
function UserName() {
  const userName = useUserStore(state => state.user?.name);
  return <div>{userName}</div>;
}
```

### Zustand with Middleware
```typescript
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

interface CartItem {
  id: string;
  name: string;
  quantity: number;
  price: number;
}

interface CartState {
  items: CartItem[];
  addItem: (item: CartItem) => void;
  removeItem: (id: string) => void;
  updateQuantity: (id: string, quantity: number) => void;
  clearCart: () => void;
  getTotalPrice: () => number;
}

export const useCartStore = create<CartState>()(
  devtools(
    persist(
      immer((set, get) => ({
        items: [],

        addItem: (item) =>
          set((state) => {
            const existingItem = state.items.find((i) => i.id === item.id);
            if (existingItem) {
              existingItem.quantity += item.quantity;
            } else {
              state.items.push(item);
            }
          }),

        removeItem: (id) =>
          set((state) => {
            state.items = state.items.filter((item) => item.id !== id);
          }),

        updateQuantity: (id, quantity) =>
          set((state) => {
            const item = state.items.find((i) => i.id === id);
            if (item) {
              item.quantity = quantity;
            }
          }),

        clearCart: () => set({ items: [] }),

        getTotalPrice: () => {
          const items = get().items;
          return items.reduce((sum, item) => sum + item.price * item.quantity, 0);
        },
      })),
      {
        name: 'cart-storage',
      }
    ),
    {
      name: 'CartStore',
    }
  )
);
```

### Zustand Slices Pattern
```typescript
// stores/slices/authSlice.ts
export interface AuthSlice {
  user: User | null;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
}

export const createAuthSlice: StateCreator<
  StoreState,
  [],
  [],
  AuthSlice
> = (set) => ({
  user: null,
  isAuthenticated: false,
  
  login: async (email, password) => {
    const user = await authenticateUser(email, password);
    set({ user, isAuthenticated: true });
  },
  
  logout: () => set({ user: null, isAuthenticated: false }),
});

// stores/slices/settingsSlice.ts
export interface SettingsSlice {
  theme: 'light' | 'dark';
  language: string;
  setTheme: (theme: 'light' | 'dark') => void;
  setLanguage: (language: string) => void;
}

export const createSettingsSlice: StateCreator<
  StoreState,
  [],
  [],
  SettingsSlice
> = (set) => ({
  theme: 'light',
  language: 'en',
  setTheme: (theme) => set({ theme }),
  setLanguage: (language) => set({ language }),
});

// stores/index.ts
type StoreState = AuthSlice & SettingsSlice;

export const useStore = create<StoreState>()((...a) => ({
  ...createAuthSlice(...a),
  ...createSettingsSlice(...a),
}));
```

## Derived State

```typescript
// BAD - Storing derived state
function ProductList({ products }: { products: Product[] }) {
  const [filteredProducts, setFilteredProducts] = useState(products);
  const [searchTerm, setSearchTerm] = useState('');

  useEffect(() => {
    setFilteredProducts(
      products.filter(p => p.name.includes(searchTerm))
    );
  }, [products, searchTerm]);

  // ...
}

// GOOD - Compute derived state
function ProductList({ products }: { products: Product[] }) {
  const [searchTerm, setSearchTerm] = useState('');

  // Computed during render - no sync issues
  const filteredProducts = useMemo(
    () => products.filter(p => p.name.toLowerCase().includes(searchTerm.toLowerCase())),
    [products, searchTerm]
  );

  // ...
}
```

## Custom Hooks for State Logic

```typescript
// hooks/useToggle.ts
export function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);

  const toggle = useCallback(() => setValue(v => !v), []);
  const setTrue = useCallback(() => setValue(true), []);
  const setFalse = useCallback(() => setValue(false), []);

  return { value, toggle, setTrue, setFalse };
}

// hooks/useLocalStorage.ts
export function useLocalStorage<T>(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  const setValue = useCallback(
    (value: T | ((val: T) => T)) => {
      try {
        const valueToStore = value instanceof Function ? value(storedValue) : value;
        setStoredValue(valueToStore);
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      } catch (error) {
        console.error(error);
      }
    },
    [key, storedValue]
  );

  return [storedValue, setValue] as const;
}

// hooks/useDebounce.ts
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(handler);
  }, [value, delay]);

  return debouncedValue;
}

// Usage
function SearchInput() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  useEffect(() => {
    if (debouncedSearchTerm) {
      performSearch(debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);

  return (
    <input
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
    />
  );
}
```

## State Management Anti-Patterns

- ❌ Storing derived state in useState
- ❌ Prop drilling more than 2-3 levels
- ❌ Using context for frequently changing values (performance issue)
- ❌ Not memoizing context values
- ❌ Putting everything in global state
- ❌ Multiple sources of truth for the same data
- ❌ Mixing server state and client state
- ❌ Not using selectors with Zustand (causes unnecessary re-renders)
- ❌ Storing data that belongs to URL in state (use React Router instead)

## Best Practices

- ✅ Keep state as local as possible
- ✅ Use TanStack Query for server state
- ✅ Use Zustand for complex client state
- ✅ Use Context for rarely-changing global values (theme, locale)
- ✅ Memoize context values
- ✅ Use selectors to prevent unnecessary re-renders
- ✅ Prefer composition over deep prop drilling
- ✅ Derive state instead of storing it
- ✅ Use URL for shareable state (filters, pagination)
- ✅ Test state logic in isolation

**See also:** `data-fetching.mdc`, `components.mdc`, `routing.mdc`, `performance.mdc`
