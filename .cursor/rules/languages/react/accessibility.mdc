---
description: "Accessibility (a11y) - ARIA patterns, keyboard navigation, focus management, screen reader support"
globs: ["**/components/**/*.tsx", "**/*.tsx"]
---

# Accessibility (a11y)

## Principles

### WCAG 2.1 Guidelines
- **Perceivable** - Information must be presentable to users in ways they can perceive
- **Operable** - UI components must be operable by all users
- **Understandable** - Information and UI operation must be understandable
- **Robust** - Content must be robust enough to work with assistive technologies

## Semantic HTML

### Use Proper HTML Elements
```typescript
// ✅ GOOD - Semantic HTML
<button onClick={handleClick}>
  Click me
</button>

<nav>
  <ul>
    <li><a href="/home">Home</a></li>
    <li><a href="/about">About</a></li>
  </ul>
</nav>

// ❌ BAD - Non-semantic divs
<div onClick={handleClick}>
  Click me
</div>

<div>
  <div onClick={() => navigate('/home')}>Home</div>
  <div onClick={() => navigate('/about')}>About</div>
</div>
```

### Headings Hierarchy
```typescript
// ✅ GOOD - Proper hierarchy
<article>
  <h1>Page Title</h1>
  <section>
    <h2>Section Title</h2>
    <h3>Subsection</h3>
  </section>
  <section>
    <h2>Another Section</h2>
  </section>
</article>

// ❌ BAD - Skipping levels
<article>
  <h1>Page Title</h1>
  <h4>Subsection</h4> {/* Skips h2 and h3 */}
</article>
```

## ARIA Attributes

### Landmark Roles
```typescript
<header role="banner">
  <nav role="navigation" aria-label="Main navigation">
    {/* nav items */}
  </nav>
</header>

<main role="main">
  {/* main content */}
</main>

<aside role="complementary" aria-label="Related articles">
  {/* sidebar */}
</aside>

<footer role="contentinfo">
  {/* footer */}
</footer>
```

### ARIA Labels
```typescript
// Icon button
<button aria-label="Close dialog">
  <XIcon />
</button>

// Button with visible text
<button aria-label="Delete user">
  <TrashIcon aria-hidden="true" />
  Delete
</button>

// Search input
<input
  type="search"
  aria-label="Search users"
  placeholder="Search..."
/>

// Decorative images
<img src="/decorative.svg" alt="" role="presentation" />
```

### ARIA States
```typescript
function ToggleButton() {
  const [pressed, setPressed] = useState(false);

  return (
    <button
      aria-pressed={pressed}
      onClick={() => setPressed(!pressed)}
    >
      {pressed ? 'On' : 'Off'}
    </button>
  );
}

function ExpandableSection() {
  const [expanded, setExpanded] = useState(false);

  return (
    <div>
      <button
        aria-expanded={expanded}
        aria-controls="content-1"
        onClick={() => setExpanded(!expanded)}
      >
        Toggle Content
      </button>
      {expanded && (
        <div id="content-1">
          Content here
        </div>
      )}
    </div>
  );
}
```

### Live Regions
```typescript
function StatusMessage() {
  const [message, setMessage] = useState('');

  return (
    <div
      role="status"
      aria-live="polite"
      aria-atomic="true"
    >
      {message}
    </div>
  );
}

function AlertMessage({ message }: { message: string }) {
  return (
    <div
      role="alert"
      aria-live="assertive"
    >
      {message}
    </div>
  );
}
```

## Keyboard Navigation

### Focus Management
```typescript
function Dialog({ isOpen, onClose }: DialogProps) {
  const dialogRef = useRef<HTMLDivElement>(null);
  const closeButtonRef = useRef<HTMLButtonElement>(null);
  const previousFocusRef = useRef<HTMLElement | null>(null);

  useEffect(() => {
    if (isOpen) {
      // Save previous focus
      previousFocusRef.current = document.activeElement as HTMLElement;
      
      // Focus first element
      closeButtonRef.current?.focus();
    } else {
      // Restore focus
      previousFocusRef.current?.focus();
    }
  }, [isOpen]);

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Escape') {
      onClose();
    }
  };

  if (!isOpen) return null;

  return (
    <div
      ref={dialogRef}
      role="dialog"
      aria-modal="true"
      aria-labelledby="dialog-title"
      onKeyDown={handleKeyDown}
    >
      <button
        ref={closeButtonRef}
        onClick={onClose}
        aria-label="Close dialog"
      >
        ×
      </button>
      <h2 id="dialog-title">Dialog Title</h2>
      {/* dialog content */}
    </div>
  );
}
```

### Focus Trap
```typescript
import { useRef, useEffect } from 'react';

function useFocusTrap(isActive: boolean) {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!isActive) return;

    const container = containerRef.current;
    if (!container) return;

    const focusableElements = container.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );

    const firstElement = focusableElements[0] as HTMLElement;
    const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;

    const handleTab = (e: KeyboardEvent) => {
      if (e.key !== 'Tab') return;

      if (e.shiftKey) {
        // Shift + Tab
        if (document.activeElement === firstElement) {
          e.preventDefault();
          lastElement.focus();
        }
      } else {
        // Tab
        if (document.activeElement === lastElement) {
          e.preventDefault();
          firstElement.focus();
        }
      }
    };

    container.addEventListener('keydown', handleTab);
    return () => container.removeEventListener('keydown', handleTab);
  }, [isActive]);

  return containerRef;
}

// Usage
function Modal({ isOpen }: { isOpen: boolean }) {
  const trapRef = useFocusTrap(isOpen);

  if (!isOpen) return null;

  return (
    <div ref={trapRef} role="dialog" aria-modal="true">
      {/* modal content */}
    </div>
  );
}
```

### Skip Links
```typescript
function SkipLinks() {
  return (
    <a
      href="#main-content"
      className="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:px-4 focus:py-2 focus:bg-primary focus:text-primary-foreground"
    >
      Skip to main content
    </a>
  );
}

// In layout
function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <SkipLinks />
      <header>{/* ... */}</header>
      <main id="main-content" tabIndex={-1}>
        {children}
      </main>
    </>
  );
}
```

### Keyboard Shortcuts
```typescript
function useKeyboardShortcut(
  key: string,
  callback: () => void,
  options: { ctrl?: boolean; shift?: boolean } = {}
) {
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === key) {
        if (options.ctrl && !e.ctrlKey) return;
        if (options.shift && !e.shiftKey) return;
        
        e.preventDefault();
        callback();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [key, callback, options]);
}

// Usage
function SearchDialog() {
  const [isOpen, setIsOpen] = useState(false);

  useKeyboardShortcut('k', () => setIsOpen(true), { ctrl: true });
  useKeyboardShortcut('Escape', () => setIsOpen(false));

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>
        Search <kbd>Ctrl+K</kbd>
      </button>
      {isOpen && <SearchModal onClose={() => setIsOpen(false)} />}
    </div>
  );
}
```

## Forms Accessibility

### Form Labels
```typescript
// ✅ GOOD - Explicit label
<div>
  <label htmlFor="email">Email</label>
  <input id="email" type="email" name="email" />
</div>

// ✅ GOOD - Implicit label
<label>
  Email
  <input type="email" name="email" />
</label>

// ✅ GOOD - aria-label when no visible label
<input
  type="search"
  aria-label="Search"
  placeholder="Search..."
/>

// ❌ BAD - No label
<input type="email" name="email" />
```

### Form Validation
```typescript
function SignupForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm();

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label htmlFor="email">Email</label>
        <input
          id="email"
          type="email"
          aria-invalid={!!errors.email}
          aria-describedby={errors.email ? 'email-error' : undefined}
          {...register('email', { required: true })}
        />
        {errors.email && (
          <span id="email-error" role="alert">
            {errors.email.message}
          </span>
        )}
      </div>

      <button type="submit">Sign Up</button>
    </form>
  );
}
```

### Required Fields
```typescript
<div>
  <label htmlFor="username">
    Username <span aria-label="required">*</span>
  </label>
  <input
    id="username"
    type="text"
    required
    aria-required="true"
  />
</div>
```

## Interactive Components

### Button Accessibility
```typescript
// ✅ GOOD - Native button
<button onClick={handleClick}>
  Click me
</button>

// ✅ GOOD - Link styled as button
<a href="/page" className="button">
  Go to page
</a>

// ⚠️ OK - Non-button with proper ARIA
<div
  role="button"
  tabIndex={0}
  onClick={handleClick}
  onKeyDown={(e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      handleClick();
    }
  }}
>
  Custom button
</div>
```

### Dropdown/Select
```typescript
function Dropdown({ options, value, onChange }: DropdownProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [activeIndex, setActiveIndex] = useState(0);

  const handleKeyDown = (e: React.KeyboardEvent) => {
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setActiveIndex((prev) => Math.min(prev + 1, options.length - 1));
        break;
      case 'ArrowUp':
        e.preventDefault();
        setActiveIndex((prev) => Math.max(prev - 1, 0));
        break;
      case 'Enter':
        e.preventDefault();
        onChange(options[activeIndex]);
        setIsOpen(false);
        break;
      case 'Escape':
        setIsOpen(false);
        break;
    }
  };

  return (
    <div>
      <button
        aria-haspopup="listbox"
        aria-expanded={isOpen}
        onClick={() => setIsOpen(!isOpen)}
      >
        {value || 'Select option'}
      </button>

      {isOpen && (
        <ul
          role="listbox"
          aria-activedescendant={`option-${activeIndex}`}
          onKeyDown={handleKeyDown}
        >
          {options.map((option, index) => (
            <li
              key={option.id}
              id={`option-${index}`}
              role="option"
              aria-selected={option === value}
              onClick={() => {
                onChange(option);
                setIsOpen(false);
              }}
            >
              {option.label}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

### Tabs
```typescript
function Tabs({ tabs }: { tabs: Tab[] }) {
  const [activeTab, setActiveTab] = useState(0);

  const handleKeyDown = (e: React.KeyboardEvent, index: number) => {
    switch (e.key) {
      case 'ArrowRight':
        setActiveTab((index + 1) % tabs.length);
        break;
      case 'ArrowLeft':
        setActiveTab((index - 1 + tabs.length) % tabs.length);
        break;
      case 'Home':
        setActiveTab(0);
        break;
      case 'End':
        setActiveTab(tabs.length - 1);
        break;
    }
  };

  return (
    <div>
      <div role="tablist" aria-label="Content tabs">
        {tabs.map((tab, index) => (
          <button
            key={tab.id}
            role="tab"
            id={`tab-${index}`}
            aria-selected={activeTab === index}
            aria-controls={`panel-${index}`}
            tabIndex={activeTab === index ? 0 : -1}
            onClick={() => setActiveTab(index)}
            onKeyDown={(e) => handleKeyDown(e, index)}
          >
            {tab.label}
          </button>
        ))}
      </div>

      {tabs.map((tab, index) => (
        <div
          key={tab.id}
          role="tabpanel"
          id={`panel-${index}`}
          aria-labelledby={`tab-${index}`}
          hidden={activeTab !== index}
          tabIndex={0}
        >
          {tab.content}
        </div>
      ))}
    </div>
  );
}
```

## Screen Reader Support

### Visually Hidden Text
```typescript
// Tailwind utility
<span className="sr-only">
  Screen reader only text
</span>

// CSS class
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}
```

### Announcing Changes
```typescript
function Toast({ message }: { message: string }) {
  return (
    <div
      role="status"
      aria-live="polite"
      aria-atomic="true"
      className="toast"
    >
      {message}
    </div>
  );
}

function ErrorAlert({ error }: { error: string }) {
  return (
    <div
      role="alert"
      aria-live="assertive"
      aria-atomic="true"
      className="error"
    >
      {error}
    </div>
  );
}
```

## Testing Accessibility

### Automated Testing with jest-axe
```typescript
import { render } from '@testing-library/react';
import { axe, toHaveNoViolations } from 'jest-axe';
import { Button } from './Button';

expect.extend(toHaveNoViolations);

describe('Button', () => {
  it('should have no accessibility violations', async () => {
    const { container } = render(<Button>Click me</Button>);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });
});
```

### Testing with React Testing Library
```typescript
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

describe('LoginForm', () => {
  it('should be keyboard accessible', async () => {
    const user = userEvent.setup();
    render(<LoginForm />);

    // Tab through form
    await user.tab();
    expect(screen.getByLabelText(/email/i)).toHaveFocus();

    await user.tab();
    expect(screen.getByLabelText(/password/i)).toHaveFocus();

    await user.tab();
    expect(screen.getByRole('button', { name: /login/i })).toHaveFocus();
  });

  it('should announce errors to screen readers', async () => {
    render(<LoginForm />);
    const submitButton = screen.getByRole('button', { name: /login/i });
    
    await userEvent.click(submitButton);

    const alert = await screen.findByRole('alert');
    expect(alert).toHaveTextContent(/email is required/i);
  });
});
```

## Color Contrast

### WCAG Contrast Requirements
```typescript
// Minimum contrast ratios:
// - Normal text: 4.5:1
// - Large text (18pt+): 3:1
// - UI components: 3:1

// ✅ GOOD - Sufficient contrast
<p className="text-gray-900 bg-white">
  High contrast text
</p>

// ❌ BAD - Insufficient contrast
<p className="text-gray-400 bg-gray-300">
  Low contrast text
</p>

// Check with tools:
// - Chrome DevTools Accessibility panel
// - WebAIM Contrast Checker
// - axe DevTools
```

## Best Practices

- ✅ Use semantic HTML elements
- ✅ Provide text alternatives for images
- ✅ Ensure keyboard accessibility
- ✅ Manage focus properly
- ✅ Use ARIA attributes correctly
- ✅ Test with screen readers
- ✅ Maintain proper heading hierarchy
- ✅ Ensure sufficient color contrast
- ✅ Provide skip links
- ✅ Test with automated tools (axe, jest-axe)
- ✅ Support keyboard shortcuts
- ✅ Announce dynamic content changes

## Anti-Patterns

- ❌ Using div/span instead of button
- ❌ Images without alt text
- ❌ Keyboard traps
- ❌ Missing form labels
- ❌ Improper ARIA usage
- ❌ Skipping heading levels
- ❌ Low color contrast
- ❌ Not managing focus
- ❌ No keyboard support
- ❌ Relying solely on color for information
- ❌ Not testing with assistive technologies

## Accessibility Checklist

- [ ] All interactive elements keyboard accessible
- [ ] All images have alt text
- [ ] All form inputs have labels
- [ ] Proper heading hierarchy
- [ ] Color contrast meets WCAG standards
- [ ] Focus indicators visible
- [ ] Skip links implemented
- [ ] ARIA attributes used correctly
- [ ] Screen reader tested
- [ ] Automated accessibility tests pass
- [ ] Error messages announced to screen readers
- [ ] Modal dialogs trap focus

## Tools & Resources

### Testing Tools
- **axe DevTools** - Browser extension
- **Lighthouse** - Chrome DevTools
- **WAVE** - Web accessibility evaluation tool
- **jest-axe** - Automated testing

### Screen Readers
- **NVDA** - Windows (free)
- **JAWS** - Windows
- **VoiceOver** - macOS/iOS
- **TalkBack** - Android

### Documentation
- [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)
- [ARIA Authoring Practices](https://www.w3.org/WAI/ARIA/apg/)
- [MDN Accessibility](https://developer.mozilla.org/en-US/docs/Web/Accessibility)

**See also:** `components.mdc`, `forms.mdc`, `../../patterns/architecture.mdc`
